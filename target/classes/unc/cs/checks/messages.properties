methodlimit = {0} {1} max. number of methods is {1}
variableHasClassType = {0} {1} Class {2} rather than interface used as the type of variable/function {3}
classIsNotType = {0} {1} A class should implement a single (possibly extending) interface
noDuplicateShortTypeName = {0} {1} Repeated short type name {2}, many checks for it will not work
noFullTypeName = {0} {1} Used full type name {3}
interfaceDefined = {0} {1} Interface {2} matching tag {3} defined
typeDefined = {0} {1} Class/Interface {2} matching tag {3} defined
classDefined = {0} {1} Class/Interface {2} matching tag {3} defined
expectedTypes = Expected type names/tags {2}
classIsGeneric = {0} {1} should be generic
classHasOneInterface = {0} {1} A class with instance methods should have exactly one (possibly extending and empty) interface      
classHasAtLeastOneInterface = {0} {1} Classes with public instance methods should implement interfaces
illegalMethodCall = {0} {1} called disallowed method {3}
uncessaryMethodCall = {0} {1} called unnecessary method {2}
legalMethodCall = {0} {1} called legal method {3}
expectedMethodCall = {0} {1} called expected method {2}
missingMethodCall = {0} {1} has not made expected call {3}
illegalTypeDefined = {0} {1} You are expected to use existing version of type {2} rather than provide your own code for it
illegalTypeImported = {0} {1} Used disallowed class {3} 
illegalInitCall = {0} {1} init method {2} should be called by an init method or a constructor
legalInitCall = {0} {1} init method {2} called by an init method or a constructor
illegalComponentInstantiation = {0} {1} Instantiation of property class {2} should occur in init or constructor
legalComponentInstantiation = {0} {1} Instantiation of property class {2} occurred in init or constructor
staticVariable = {0} {1} Non final static variable {2} defined, should it be instance or final?
functionAssignsGlobal ={0} {1} Function {2} assigns to a global variable 
setterAssignsGlobal = {0} {1} Setter {2} does not assign to a global variable 
noStructuredSetter = {0} {1} Setter for property {2} of type {3} should not be defined
expectedGlobals = {0} {1} In type {2} missing global variable {3} of type {4}
expectedGetters = {0} {1} Missing getter for property {3} of type {4}
expectedSetters = {0} {1} Missing setter for property {3} of type {4}
expectedSignatures = {0} {1} In type {4}, missing signature: {3}
expectedDeclaredSignatures = {0} {1} In type {4}, missing declared signature: {3}
expectedClassInstantiations = {0} {1} Type {4} should be instantiated by {3} 
multipleInstantiatingMethods = {0} {1} Type {3} should be instantiated (only) by {2} rather than {4}
invalidClassInstantiation = {0} {1} Class {3} should not instantiate {4}
expectedConstructors = {0} {1} In type {4}, missing constructor: {3}
expectedPattern = {0} {1} In type {3}, missing pattern: {2}
expectedInterfaces = {0} {1} In type {4}, missing interface: {3}
expectedSuperTypes = {0} {1} In type {3}, missing supertype: {2}
invalidSuperTypes = {0} {1} Type {3} should not have super type {2}
peerCommonSignatures = {0} {1} Signature {2} common between {3} and {4} not inherited
peerCommonProperties = {0} {1} Property {2} common between {3} and {4} not inherited
minComponentObjects = {0} {1} Min object components: {3}, actual {2}
minDeclaredMethods = {0} {1} Min declared methods: {3}, actual {2}
minCalledMethods = {0} {1} Min called methods: {3}, actual {2}
minDescendantObjects = {0} {1} Min object descendants: {3}, actual {2}
minDescendantShapes = {0} {1} Min shape descendants: {3}, actual {2}
missingPropertyNotification = {0} {1} Notified property {3}  does not have a getter
invalidPropertyNotification = {0} {1} Notified property {3} should be a string literal or a global constant in notifying class (for checks to work)
structuredPropertyNotification = {0} {1} Notified property {2} is structured
missingActualProperty = {0} {1} Declared property {2} does not have a getter
missingActualEditableProperty = {0} {1} Declared editable property {2} does not have a setter
invalidPackageName = {0} {1} Package name {3} does not have one of the following prefixes {4}
stBuilder = {0} {1}  Symbol table built for {2}
expectedConstructs = {0} {1} In type {3}, specification {2}, matching construct {4} not found
expectedNodes = {0} {1} In type {3}, specification {2}, node {4} not matched
bulkierThen = {0} {1} In type {2},  then part much bulkier than else part of if. Invert if condition to swap then and else blocks.
nestedBlockDepth = {0} {1} In type {2}, loop level {3} greater than max {4}, consider making it a separate method unless it introduces unsafe global variables 
methodBlockLimit = {0} {1} In type {2}, method {3}, loop count {4} greater than max {5}, consider making it a separate method unless it introduces unsafe global variables 
thenBranching = {0} {1} In type {2},  method {3}, rewrite if to use else-ifs  rather than nested ifs (that is, use else branching instead of then branching)
classDecomposition = {0} {1} In type {2}, consider separarting the following method sets into different types {3}

